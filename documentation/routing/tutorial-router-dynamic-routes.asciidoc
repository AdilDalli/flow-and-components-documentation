---
title: Dynamic Route Registration
order: 10
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]
== Dynamic Route Registration

The `RouteRegistry` contains the collection of navigation targets that can be
navigated to for a Flow application.

The normal way in Flow is to registers routes using the static `@Route` annotation on a
class that is then added to an application scoped registry on servlet initialization.
These routes are available for all users navigating to the mapped path.
For more information on static routes see <<tutorial-routing-annotation#,Defining Routes with @Route>>.

In some cases there might be a need to add or remove a route due to changed data
or application state.
This might mean adding an entry point to the system (application scope) or new
targets for a logged in user (session scope).

To add a new route to a `RouteRegistry` you need to define the path, target `Component` and the parent layouts.

With all the needed parts registering a route is done as:

[source, java]
----
routeRegistry.setRoute("home", Home.class, Collections.emptyList());
----

[source, java]
----
List<Class<? extends RouterLayout>> parentLayouts = Arrays.asList(MainLayout.class);
routeRegistry.setRoute("home", Home.class, parentLayouts);
----

To get the registry see: <<Getting a route registry>>

For information on parent layouts see <<tutorial-router-layout#,Router Layouts and Nested Router Targets>>.

[NOTE]
When dynamically registering a route any annotations on the classes *will* be ignored.

To remove a route from a `RouteRegistry` you need to define decide if what you want to
remove is the path (e.g. "users"), the navigation target (e.g. `Users.class`) with all route aliases
or a single navigation target registered to a path (e.g. `Users.class` from "users" where there will
be left a parameter target "users/{id}").

[source, java]
----
// No path "users" should be available
routeRegistry.removeRoute("users");

// No navigationTarget Users should be available
routeRegistry.removeRoute(Users.class);

// Only the Users navigationTarget should be removed from "users"
routeRegistry.removeRoute("users", Users.class);
----

For routes with route aliases see: <<Adding route aliases for dynamic routes>>
For information on multiple navigation targets on a single path see: <<tutorial-router-url-parameters#,URL Parameters for Navigation Targets>>

[NOTE]
Removing a route in session scope will not create a removal mask and any route
masked in the application scope by the removed route will be visible.


=== Adding route aliases for dynamic routes

When adding dynamic routes the first path for which the navigation target is added
will be marked as the main path and be returned for the `Router.getUrl` methods.

Any additional paths registered will be seen as a route alias.

So for the registrations:

[source, java]
----
routeRegistry.setRoute("main", MyRoute.class, Collections.emptyList());
routeRegistry.setRoute("info", MyRoute.class, Collections.emptyList());
routeRegistry.setRoute("version", MyRoute.class, Collections.emptyList());
----

In this scenario `Router.getUrl(MyRoute.class)` would return `main`.

This is the same as having the static class definition:

[source, java]
----
@Route("main")
@RouteAlias("info")
@RouteAlias("version")
private class MyRoute extends Div {
}
----

In case the main path gets removed and an alias path is still left for use, then
the main path will be updated to the first alias path found from the registry.


=== Getting a route registry

The session scoped route registry is tied to the `VaadinSession`

[source, java]
----
VaadinSession session = VaadinSession.getCurrent();
RouteRegistry sessionRegistry = SessionRouteRegistry.getSessionRegistry(session);
----

[NOTE]
`SessionRouteRegistry` is active for the session and will be removed when the session is closed.
Any routes registered to this registry will be only available for the `VaadinSession`, this means
that it is available for all the `UI` instances inside the same session.

The application scoped registry is tied to the `ServletContext`.

[source, java]
----
ServletContext servletContext = VaadinServlet.getCurrent().getServletContext();
RouteRegistry registry = ApplicationRouteRegistry.getInstance(servletContext);
----

[NOTE]
When adding or removing routes from the `ApplicationRouteRegistry` it should be
well understood that it will have an impact on every user of the system.

==== Example: Adding a new view on user login

Our application contains 2 statically registered routes "" and "info".
Where "" maps to a login for user authentication and "info" would be a route
that has some data on the application version for instance.

[[Login.class]]
.Login.class
[source, java]
----
@Route("")
public class Login extends Div {

    private TextField login;
    private PasswordField password;

    public Login() {
        login = new TextField("Login");
        password = new PasswordField("Password");

        Button submit = new Button("Submit", this::handeLogin);

        add(login, password, submit);
    }

    private void handeLogin(ClickEvent<Button> buttonClickEvent) {
    }
}
----

.Info.class
[source, java]
----
@Route("info")
public class Info extends Div {
    public Info() {
        add(new Span("This page contains info about the application"));
    }
}
----

After a user has logged in we want to add a new route for that user depending
on who logged in.

As available targets we have:

.Admin.class
[source, java]
----
public class Admin extends Div {
}
----

.User.class
[source, java]
----
public class User extends Div {
}
----


In Login we would handle the adding to only the user session as:

[source, java]
----
private void handeLogin(ClickEvent<Button> buttonClickEvent) {
    // Validation of credentials is skipped

    RouteRegistry sessionRegistry = SessionRouteRegistry
                    .getSessionRegistry(VaadinSession.getCurrent());

    if ("admin".equals(login.getValue())) {
        sessionRegistry.setRoute("", Admin.class, Collections.emptyList());
    } else if("user".equals(login.getValue())) {
        sessionRegistry.setRoute("", User.class, Collections.emptyList());
    }

    UI.getCurrent().getPage().reload();
}
----

Here we add to the session scoped route registry a new target for the path "" which will
mask the application scoped path "".

[NOTE]
This still means that other users on other sessions get
Login for the "" path.
